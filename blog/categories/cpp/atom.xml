<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: cpp | /home/ankit]]></title>
  <link href="http://goyalankit.github.io/blog/categories/cpp/atom.xml" rel="self"/>
  <link href="http://goyalankit.github.io/"/>
  <updated>2014-03-25T19:11:58-05:00</updated>
  <id>http://goyalankit.github.io/</id>
  <author>
    <name><![CDATA[Ankit Goyal]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[learning concept checking the hard way - part 1]]></title>
    <link href="http://goyalankit.github.io/blog/2014/03/21/learning-concept-checking-the-hard-way-1/"/>
    <updated>2014-03-21T15:27:00-05:00</updated>
    <id>http://goyalankit.github.io/blog/2014/03/21/learning-concept-checking-the-hard-way-1</id>
    <content type="html"><![CDATA[<p>What is a concept in C++?</p>

<blockquote><p>A concept is a set of requirements (valid expressions, associated types, semantic invariants, complexity guarantees, etc.)
that a type must fulfill to be correctly used as arguments in a call to a generic algorithm</p></blockquote>

<p>For example if you write your own generic implementation for
<code>BinarySearchTree</code>. It should basically work for any type for which <code>&lt;</code>
operator is defined. As long as you have that condition satisfied you
can build a binary search tree for that type. For instance, <code>&lt;</code> is defined for
<code>int</code>, <code>double</code>. However it&rsquo;s not defined for <code>complex</code> numbers. C++ has
no explicit mechanism for representing concepts.</p>

<p>Consider the following possible way
you may write your generic Binary Search Tree.</p>

<p>```c++</p>

<h1>include<iostream></h1>

<p>template <typename T>
class BinarySearchTree{</p>

<pre><code>public:
// dummy method to insert a new node to the tree
void insert(T value, T parent){
    // calling `&lt;` operator. Compilation will fail if it doesn't exist
    // for a type.
    if(value &lt; parent){
        std::cout &lt;&lt; "Less than operator exists" &lt;&lt; std::endl;
        //insert to the left of binary tree.
    }
}
</code></pre>

<p>};</p>

<p>int main(int argc, char* argv[]){</p>

<pre><code>// instantiating template with int
BinarySearchTree&lt;int&gt; bint;
bint.insert(1,2);
// instantiating template with double
BinarySearchTree&lt;double&gt; bdouble;
bdouble.insert(1.23,3.13);

return 0;
</code></pre>

<p>}</p>

<p>```</p>

<p>```</p>

<blockquote><blockquote><p>g++ b.cpp -o btree
./btree
Less than operator exists
Less than operator exists
```</p></blockquote></blockquote>

<p>Awesome, so it works for both doube and int, since <code>&lt;</code> is defined for
them. What happens if you try it with complex numbers? let&rsquo;s see:</p>

<p>```
//include the complex lib</p>

<h1>include <complex></h1>

<p>// In main function
// instantiating template with complex
BinarySearchTree&lt;std::complex<int> > bcomplex;
bcomplex.insert(std::complex<int>(1,2), std::complex<int>(4,5));</p>

<p>```</p>

<p>If you try to run your <code>BinarySearchTree</code> implementation for <code>complex</code>
numbers you will get a compile time error. So the question is how do you
check if a class has a certain method defined or not. Above Example is a
trivial example to show you the use case, the error could be buried deep
into your code and may not represent the actual reason for
failure. Boost documentation gives a <a href="http://www.boost.org/doc/libs/1_55_0/libs/concept_check/concept_check.htm"> good example </a>.</p>

<p>In short it would be good to have a <code>has_less</code> method for a generic type
that determines if the given type has a <code>&lt;</code> method defined or not. Using
this method you can give your user a more meaningful error.</p>

<p>Note that you can use concept checking provided by boost library. You&rsquo;d
need to do something like this:</p>

<p>```</p>

<h1>include &lt;boost/concept_check.hpp></h1>

<p>//inside class
BOOST_CLASS_REQUIRE(T, boost, LessThanComparableConcept);</p>

<p>```</p>

<p>For more info: visit <a href="http://www.boost.org/doc/libs/1_55_0/libs/concept_check/using_concept_check.htm">http://www.boost.org/doc/libs/1_55_0/libs/concept_check/using_concept_check.htm</a></p>

<p>In the <a href="http://goyalankit.com/blog/2014/03/24/learning-concept-checking-the-hard-way-2/">next post</a>, we&rsquo;ll implement our own short version of concept
checking. It involves some really cool template tricks and C++ trivia.</p>

<p>Feel free to comment and give suggestions.</p>

<p>References:</p>

<ol>
<li><a href="http://www.boost.org/doc/libs/1_55_0/libs/concept_check/concept_check.htm">http://www.boost.org/doc/libs/1_55_0/libs/concept_check/concept_check.htm</a></li>
</ol>

]]></content>
  </entry>
  
</feed>
